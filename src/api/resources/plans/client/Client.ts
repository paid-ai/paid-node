// This file was auto-generated by Fern from our API Definition.

import type { BaseClientOptions, BaseRequestOptions } from "../../../../BaseClient.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "../../../../core/headers.js";
import * as core from "../../../../core/index.js";
import * as environments from "../../../../environments.js";
import * as errors from "../../../../errors/index.js";
import * as Paid from "../../../index.js";

export declare namespace Plans {
    export interface Options extends BaseClientOptions {}

    export interface RequestOptions extends BaseRequestOptions {}
}

export class Plans {
    protected readonly _options: Plans.Options;

    constructor(_options: Plans.Options = {}) {
        this._options = _options;
    }

    /**
     * Retrieves the currently active plan subscription for a customer by their external ID. Returns the plan details and subscription information.
     *
     * @param {Paid.PlansGetCurrentRequest} request
     * @param {Plans.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Paid.BadRequestError}
     * @throws {@link Paid.ForbiddenError}
     * @throws {@link Paid.NotFoundError}
     *
     * @example
     *     await client.plans.getCurrent({
     *         customerExternalId: "customerExternalId"
     *     })
     */
    public getCurrent(
        request: Paid.PlansGetCurrentRequest,
        requestOptions?: Plans.RequestOptions,
    ): core.HttpResponsePromise<Paid.PlansGetCurrentResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getCurrent(request, requestOptions));
    }

    private async __getCurrent(
        request: Paid.PlansGetCurrentRequest,
        requestOptions?: Plans.RequestOptions,
    ): Promise<core.WithRawResponse<Paid.PlansGetCurrentResponse>> {
        const { customerExternalId } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams.customerExternalId = customerExternalId;
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PaidEnvironment.Production,
                "plans/current",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Paid.PlansGetCurrentResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Paid.BadRequestError(_response.error.body as Paid.Error_, _response.rawResponse);
                case 403:
                    throw new Paid.ForbiddenError(_response.error.body as Paid.Error_, _response.rawResponse);
                case 404:
                    throw new Paid.NotFoundError(_response.error.body as Paid.Error_, _response.rawResponse);
                default:
                    throw new errors.PaidError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PaidError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PaidTimeoutError("Timeout exceeded when calling GET /plans/current.");
            case "unknown":
                throw new errors.PaidError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} planId - The ID of the plan
     * @param {Plans.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Paid.ForbiddenError}
     * @throws {@link Paid.NotFoundError}
     *
     * @example
     *     await client.plans.getById("planId")
     */
    public getById(planId: string, requestOptions?: Plans.RequestOptions): core.HttpResponsePromise<Paid.Plan> {
        return core.HttpResponsePromise.fromPromise(this.__getById(planId, requestOptions));
    }

    private async __getById(
        planId: string,
        requestOptions?: Plans.RequestOptions,
    ): Promise<core.WithRawResponse<Paid.Plan>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PaidEnvironment.Production,
                `plans/${core.url.encodePathParam(planId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Paid.Plan, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 403:
                    throw new Paid.ForbiddenError(_response.error.body as Paid.Error_, _response.rawResponse);
                case 404:
                    throw new Paid.NotFoundError(_response.error.body as Paid.Error_, _response.rawResponse);
                default:
                    throw new errors.PaidError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PaidError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PaidTimeoutError("Timeout exceeded when calling GET /plans/{planId}.");
            case "unknown":
                throw new errors.PaidError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} planId - The ID of the plan
     * @param {Paid.PlansGetUsageRequest} request
     * @param {Plans.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Paid.BadRequestError}
     * @throws {@link Paid.ForbiddenError}
     * @throws {@link Paid.NotFoundError}
     *
     * @example
     *     await client.plans.getUsage("planId", {
     *         externalId: "externalId",
     *         limit: 1,
     *         offset: 1,
     *         startTime: "2024-01-15T09:30:00Z",
     *         endTime: "2024-01-15T09:30:00Z"
     *     })
     */
    public getUsage(
        planId: string,
        request: Paid.PlansGetUsageRequest,
        requestOptions?: Plans.RequestOptions,
    ): core.HttpResponsePromise<Paid.UsageSummariesResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getUsage(planId, request, requestOptions));
    }

    private async __getUsage(
        planId: string,
        request: Paid.PlansGetUsageRequest,
        requestOptions?: Plans.RequestOptions,
    ): Promise<core.WithRawResponse<Paid.UsageSummariesResponse>> {
        const { externalId, limit, offset, startTime, endTime } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams.externalId = externalId;
        if (limit != null) {
            _queryParams.limit = limit.toString();
        }

        if (offset != null) {
            _queryParams.offset = offset.toString();
        }

        if (startTime != null) {
            _queryParams.startTime = startTime;
        }

        if (endTime != null) {
            _queryParams.endTime = endTime;
        }

        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PaidEnvironment.Production,
                `plans/${core.url.encodePathParam(planId)}/usage`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Paid.UsageSummariesResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Paid.BadRequestError(_response.error.body as Paid.Error_, _response.rawResponse);
                case 403:
                    throw new Paid.ForbiddenError(_response.error.body as Paid.Error_, _response.rawResponse);
                case 404:
                    throw new Paid.NotFoundError(_response.error.body as Paid.Error_, _response.rawResponse);
                default:
                    throw new errors.PaidError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PaidError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PaidTimeoutError("Timeout exceeded when calling GET /plans/{planId}/usage.");
            case "unknown":
                throw new errors.PaidError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Creates a new order for a customer subscribing to a plan. The order will be created with the plan's products and pricing attributes.
     *
     * @param {string} planId - The ID of the plan
     * @param {Paid.PlansSubscribeRequest} request
     * @param {Plans.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Paid.BadRequestError}
     * @throws {@link Paid.ForbiddenError}
     * @throws {@link Paid.NotFoundError}
     *
     * @example
     *     await client.plans.subscribe("planId", {
     *         customerExternalId: "customerExternalId",
     *         currency: "currency"
     *     })
     */
    public subscribe(
        planId: string,
        request: Paid.PlansSubscribeRequest,
        requestOptions?: Plans.RequestOptions,
    ): core.HttpResponsePromise<Paid.Order> {
        return core.HttpResponsePromise.fromPromise(this.__subscribe(planId, request, requestOptions));
    }

    private async __subscribe(
        planId: string,
        request: Paid.PlansSubscribeRequest,
        requestOptions?: Plans.RequestOptions,
    ): Promise<core.WithRawResponse<Paid.Order>> {
        const { customerExternalId, currency } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams.customerExternalId = customerExternalId;
        _queryParams.currency = currency;
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PaidEnvironment.Production,
                `plans/${core.url.encodePathParam(planId)}/subscribe`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Paid.Order, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Paid.BadRequestError(_response.error.body as Paid.Error_, _response.rawResponse);
                case 403:
                    throw new Paid.ForbiddenError(_response.error.body as Paid.Error_, _response.rawResponse);
                case 404:
                    throw new Paid.NotFoundError(_response.error.body as Paid.Error_, _response.rawResponse);
                default:
                    throw new errors.PaidError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PaidError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PaidTimeoutError("Timeout exceeded when calling POST /plans/{planId}/subscribe.");
            case "unknown":
                throw new errors.PaidError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Cancels the renewal of an active order for a customer's plan subscription. The order will remain active until the cancellation date.
     *
     * @param {string} planId - The ID of the plan
     * @param {Paid.PlansUnsubscribeRequest} request
     * @param {Plans.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Paid.BadRequestError}
     * @throws {@link Paid.ForbiddenError}
     * @throws {@link Paid.NotFoundError}
     *
     * @example
     *     await client.plans.unsubscribe("planId", {
     *         customerExternalId: "customerExternalId"
     *     })
     */
    public unsubscribe(
        planId: string,
        request: Paid.PlansUnsubscribeRequest,
        requestOptions?: Plans.RequestOptions,
    ): core.HttpResponsePromise<Paid.CancelRenewalResponse> {
        return core.HttpResponsePromise.fromPromise(this.__unsubscribe(planId, request, requestOptions));
    }

    private async __unsubscribe(
        planId: string,
        request: Paid.PlansUnsubscribeRequest,
        requestOptions?: Plans.RequestOptions,
    ): Promise<core.WithRawResponse<Paid.CancelRenewalResponse>> {
        const { customerExternalId } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams.customerExternalId = customerExternalId;
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PaidEnvironment.Production,
                `plans/${core.url.encodePathParam(planId)}/unsubscribe`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Paid.CancelRenewalResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Paid.BadRequestError(_response.error.body as Paid.Error_, _response.rawResponse);
                case 403:
                    throw new Paid.ForbiddenError(_response.error.body as Paid.Error_, _response.rawResponse);
                case 404:
                    throw new Paid.NotFoundError(_response.error.body as Paid.Error_, _response.rawResponse);
                default:
                    throw new errors.PaidError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PaidError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PaidTimeoutError("Timeout exceeded when calling POST /plans/{planId}/unsubscribe.");
            case "unknown":
                throw new errors.PaidError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Upgrades a customer from one plan to another with automatic proration. Credits are applied for the unused portion of the current billing period, and the order is updated with the new plan's pricing.
     *
     * @param {Paid.PlansUpgradeRequest} request
     * @param {Plans.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Paid.BadRequestError}
     * @throws {@link Paid.ForbiddenError}
     * @throws {@link Paid.NotFoundError}
     *
     * @example
     *     await client.plans.upgrade({
     *         customerExternalId: "customerExternalId",
     *         oldPlanId: "oldPlanId",
     *         newPlanId: "newPlanId"
     *     })
     */
    public upgrade(
        request: Paid.PlansUpgradeRequest,
        requestOptions?: Plans.RequestOptions,
    ): core.HttpResponsePromise<Paid.ProrationUpgradeResponse> {
        return core.HttpResponsePromise.fromPromise(this.__upgrade(request, requestOptions));
    }

    private async __upgrade(
        request: Paid.PlansUpgradeRequest,
        requestOptions?: Plans.RequestOptions,
    ): Promise<core.WithRawResponse<Paid.ProrationUpgradeResponse>> {
        const { customerExternalId, oldPlanId, newPlanId } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams.customerExternalId = customerExternalId;
        _queryParams.oldPlanId = oldPlanId;
        _queryParams.newPlanId = newPlanId;
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PaidEnvironment.Production,
                "plans/upgrade",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Paid.ProrationUpgradeResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 400:
                    throw new Paid.BadRequestError(_response.error.body as Paid.Error_, _response.rawResponse);
                case 403:
                    throw new Paid.ForbiddenError(_response.error.body as Paid.Error_, _response.rawResponse);
                case 404:
                    throw new Paid.NotFoundError(_response.error.body as Paid.Error_, _response.rawResponse);
                default:
                    throw new errors.PaidError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PaidError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PaidTimeoutError("Timeout exceeded when calling POST /plans/upgrade.");
            case "unknown":
                throw new errors.PaidError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} planGroupId - The ID of the plan group
     * @param {Plans.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Paid.ForbiddenError}
     * @throws {@link Paid.NotFoundError}
     *
     * @example
     *     await client.plans.getGroupById("planGroupId")
     */
    public getGroupById(
        planGroupId: string,
        requestOptions?: Plans.RequestOptions,
    ): core.HttpResponsePromise<Paid.PlanGroup> {
        return core.HttpResponsePromise.fromPromise(this.__getGroupById(planGroupId, requestOptions));
    }

    private async __getGroupById(
        planGroupId: string,
        requestOptions?: Plans.RequestOptions,
    ): Promise<core.WithRawResponse<Paid.PlanGroup>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PaidEnvironment.Production,
                `plans/planGroup/${core.url.encodePathParam(planGroupId)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Paid.PlanGroup, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 403:
                    throw new Paid.ForbiddenError(_response.error.body as Paid.Error_, _response.rawResponse);
                case 404:
                    throw new Paid.NotFoundError(_response.error.body as Paid.Error_, _response.rawResponse);
                default:
                    throw new errors.PaidError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PaidError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PaidTimeoutError("Timeout exceeded when calling GET /plans/planGroup/{planGroupId}.");
            case "unknown":
                throw new errors.PaidError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieves all plans in a plan group with their features (product-attribute pairs)
     *
     * @param {string} planGroupId - The ID of the plan group
     * @param {Plans.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Paid.ForbiddenError}
     * @throws {@link Paid.NotFoundError}
     *
     * @example
     *     await client.plans.getGroupPlans("planGroupId")
     */
    public getGroupPlans(
        planGroupId: string,
        requestOptions?: Plans.RequestOptions,
    ): core.HttpResponsePromise<Paid.PlanWithFeatures[]> {
        return core.HttpResponsePromise.fromPromise(this.__getGroupPlans(planGroupId, requestOptions));
    }

    private async __getGroupPlans(
        planGroupId: string,
        requestOptions?: Plans.RequestOptions,
    ): Promise<core.WithRawResponse<Paid.PlanWithFeatures[]>> {
        const _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await core.fetcher({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.PaidEnvironment.Production,
                `plans/planGroup/${core.url.encodePathParam(planGroupId)}/plans`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: (requestOptions?.timeoutInSeconds ?? this._options?.timeoutInSeconds ?? 60) * 1000,
            maxRetries: requestOptions?.maxRetries ?? this._options?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Paid.PlanWithFeatures[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 403:
                    throw new Paid.ForbiddenError(_response.error.body as Paid.Error_, _response.rawResponse);
                case 404:
                    throw new Paid.NotFoundError(_response.error.body as Paid.Error_, _response.rawResponse);
                default:
                    throw new errors.PaidError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.PaidError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.PaidTimeoutError(
                    "Timeout exceeded when calling GET /plans/planGroup/{planGroupId}/plans.",
                );
            case "unknown":
                throw new errors.PaidError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string | undefined> {
        const bearer = await core.Supplier.get(this._options.token);
        if (bearer != null) {
            return `Bearer ${bearer}`;
        }

        return undefined;
    }
}
