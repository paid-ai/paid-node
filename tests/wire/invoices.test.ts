// This file was auto-generated by Fern from our API Definition.

import * as Paid from "../../src/api/index";
import { PaidClient } from "../../src/Client";
import { mockServerPool } from "../mock-server/MockServerPool";

describe("Invoices", () => {
    test("listInvoices (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    id: "id",
                    displayNumber: "displayNumber",
                    orderId: "orderId",
                    customerId: "customerId",
                    status: "building",
                    paymentStatus: "pending",
                    source: "order_based",
                    startDate: "2024-01-15T09:30:00Z",
                    endDate: "2024-01-15T09:30:00Z",
                    issueDate: "2024-01-15T09:30:00Z",
                    postedDate: "2024-01-15T09:30:00Z",
                    dueDate: "2024-01-15T09:30:00Z",
                    currency: "currency",
                    taxAmount: 1.1,
                    taxRate: 1.1,
                    taxStatus: "not_applicable",
                    invoiceTotalExcludingTax: 1.1,
                    invoiceTotal: 1.1,
                    amountDue: 1.1,
                    amountPaid: 1.1,
                    amountRemaining: 1.1,
                    creditNotesTotal: 1.1,
                    metadata: { key: "value" },
                    createdAt: "2024-01-15T09:30:00Z",
                    updatedAt: "2024-01-15T09:30:00Z",
                    paymentLink: "paymentLink",
                    disputeLink: "disputeLink",
                    publicUrlToken: "publicUrlToken",
                    taxExempt: true,
                    billingContactId: "billingContactId",
                },
            ],
            pagination: { limit: 1, offset: 1, total: 1, hasMore: true },
        };
        server.mockEndpoint().get("/invoices/").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.invoices.listInvoices();
        expect(response).toEqual({
            data: [
                {
                    id: "id",
                    displayNumber: "displayNumber",
                    orderId: "orderId",
                    customerId: "customerId",
                    status: "building",
                    paymentStatus: "pending",
                    source: "order_based",
                    startDate: "2024-01-15T09:30:00Z",
                    endDate: "2024-01-15T09:30:00Z",
                    issueDate: "2024-01-15T09:30:00Z",
                    postedDate: "2024-01-15T09:30:00Z",
                    dueDate: "2024-01-15T09:30:00Z",
                    currency: "currency",
                    taxAmount: 1.1,
                    taxRate: 1.1,
                    taxStatus: "not_applicable",
                    invoiceTotalExcludingTax: 1.1,
                    invoiceTotal: 1.1,
                    amountDue: 1.1,
                    amountPaid: 1.1,
                    amountRemaining: 1.1,
                    creditNotesTotal: 1.1,
                    metadata: {
                        key: "value",
                    },
                    createdAt: "2024-01-15T09:30:00Z",
                    updatedAt: "2024-01-15T09:30:00Z",
                    paymentLink: "paymentLink",
                    disputeLink: "disputeLink",
                    publicUrlToken: "publicUrlToken",
                    taxExempt: true,
                    billingContactId: "billingContactId",
                },
            ],
            pagination: {
                limit: 1,
                offset: 1,
                total: 1,
                hasMore: true,
            },
        });
    });

    test("listInvoices (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/invoices/").respondWith().statusCode(400).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.invoices.listInvoices();
        }).rejects.toThrow(Paid.BadRequestError);
    });

    test("listInvoices (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/invoices/").respondWith().statusCode(403).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.invoices.listInvoices();
        }).rejects.toThrow(Paid.ForbiddenError);
    });

    test("listInvoices (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/invoices/").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.invoices.listInvoices();
        }).rejects.toThrow(Paid.InternalServerError);
    });

    test("getInvoiceById (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = {
            id: "id",
            displayNumber: "displayNumber",
            orderId: "orderId",
            customerId: "customerId",
            status: "building",
            paymentStatus: "pending",
            source: "order_based",
            startDate: "2024-01-15T09:30:00Z",
            endDate: "2024-01-15T09:30:00Z",
            issueDate: "2024-01-15T09:30:00Z",
            postedDate: "2024-01-15T09:30:00Z",
            dueDate: "2024-01-15T09:30:00Z",
            currency: "currency",
            taxAmount: 1.1,
            taxRate: 1.1,
            taxStatus: "not_applicable",
            invoiceTotalExcludingTax: 1.1,
            invoiceTotal: 1.1,
            amountDue: 1.1,
            amountPaid: 1.1,
            amountRemaining: 1.1,
            creditNotesTotal: 1.1,
            metadata: { key: "value" },
            createdAt: "2024-01-15T09:30:00Z",
            updatedAt: "2024-01-15T09:30:00Z",
            paymentLink: "paymentLink",
            disputeLink: "disputeLink",
            publicUrlToken: "publicUrlToken",
            taxExempt: true,
            billingContactId: "billingContactId",
        };
        server.mockEndpoint().get("/invoices/id").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.invoices.getInvoiceById({
            id: "id",
        });
        expect(response).toEqual({
            id: "id",
            displayNumber: "displayNumber",
            orderId: "orderId",
            customerId: "customerId",
            status: "building",
            paymentStatus: "pending",
            source: "order_based",
            startDate: "2024-01-15T09:30:00Z",
            endDate: "2024-01-15T09:30:00Z",
            issueDate: "2024-01-15T09:30:00Z",
            postedDate: "2024-01-15T09:30:00Z",
            dueDate: "2024-01-15T09:30:00Z",
            currency: "currency",
            taxAmount: 1.1,
            taxRate: 1.1,
            taxStatus: "not_applicable",
            invoiceTotalExcludingTax: 1.1,
            invoiceTotal: 1.1,
            amountDue: 1.1,
            amountPaid: 1.1,
            amountRemaining: 1.1,
            creditNotesTotal: 1.1,
            metadata: {
                key: "value",
            },
            createdAt: "2024-01-15T09:30:00Z",
            updatedAt: "2024-01-15T09:30:00Z",
            paymentLink: "paymentLink",
            disputeLink: "disputeLink",
            publicUrlToken: "publicUrlToken",
            taxExempt: true,
            billingContactId: "billingContactId",
        });
    });

    test("getInvoiceById (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/invoices/id").respondWith().statusCode(403).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.invoices.getInvoiceById({
                id: "id",
            });
        }).rejects.toThrow(Paid.ForbiddenError);
    });

    test("getInvoiceById (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/invoices/id").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.invoices.getInvoiceById({
                id: "id",
            });
        }).rejects.toThrow(Paid.NotFoundError);
    });

    test("getInvoiceById (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/invoices/id").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.invoices.getInvoiceById({
                id: "id",
            });
        }).rejects.toThrow(Paid.InternalServerError);
    });

    test("updateInvoiceById (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            id: "id",
            displayNumber: "displayNumber",
            orderId: "orderId",
            customerId: "customerId",
            status: "building",
            paymentStatus: "pending",
            source: "order_based",
            startDate: "2024-01-15T09:30:00Z",
            endDate: "2024-01-15T09:30:00Z",
            issueDate: "2024-01-15T09:30:00Z",
            postedDate: "2024-01-15T09:30:00Z",
            dueDate: "2024-01-15T09:30:00Z",
            currency: "currency",
            taxAmount: 1.1,
            taxRate: 1.1,
            taxStatus: "not_applicable",
            invoiceTotalExcludingTax: 1.1,
            invoiceTotal: 1.1,
            amountDue: 1.1,
            amountPaid: 1.1,
            amountRemaining: 1.1,
            creditNotesTotal: 1.1,
            metadata: { key: "value" },
            createdAt: "2024-01-15T09:30:00Z",
            updatedAt: "2024-01-15T09:30:00Z",
            paymentLink: "paymentLink",
            disputeLink: "disputeLink",
            publicUrlToken: "publicUrlToken",
            taxExempt: true,
            billingContactId: "billingContactId",
        };
        server
            .mockEndpoint()
            .put("/invoices/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.invoices.updateInvoiceById({
            id: "id",
        });
        expect(response).toEqual({
            id: "id",
            displayNumber: "displayNumber",
            orderId: "orderId",
            customerId: "customerId",
            status: "building",
            paymentStatus: "pending",
            source: "order_based",
            startDate: "2024-01-15T09:30:00Z",
            endDate: "2024-01-15T09:30:00Z",
            issueDate: "2024-01-15T09:30:00Z",
            postedDate: "2024-01-15T09:30:00Z",
            dueDate: "2024-01-15T09:30:00Z",
            currency: "currency",
            taxAmount: 1.1,
            taxRate: 1.1,
            taxStatus: "not_applicable",
            invoiceTotalExcludingTax: 1.1,
            invoiceTotal: 1.1,
            amountDue: 1.1,
            amountPaid: 1.1,
            amountRemaining: 1.1,
            creditNotesTotal: 1.1,
            metadata: {
                key: "value",
            },
            createdAt: "2024-01-15T09:30:00Z",
            updatedAt: "2024-01-15T09:30:00Z",
            paymentLink: "paymentLink",
            disputeLink: "disputeLink",
            publicUrlToken: "publicUrlToken",
            taxExempt: true,
            billingContactId: "billingContactId",
        });
    });

    test("updateInvoiceById (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/invoices/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.invoices.updateInvoiceById({
                id: "id",
            });
        }).rejects.toThrow(Paid.BadRequestError);
    });

    test("updateInvoiceById (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/invoices/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(403)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.invoices.updateInvoiceById({
                id: "id",
            });
        }).rejects.toThrow(Paid.ForbiddenError);
    });

    test("updateInvoiceById (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/invoices/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.invoices.updateInvoiceById({
                id: "id",
            });
        }).rejects.toThrow(Paid.NotFoundError);
    });

    test("updateInvoiceById (5)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .put("/invoices/id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.invoices.updateInvoiceById({
                id: "id",
            });
        }).rejects.toThrow(Paid.InternalServerError);
    });

    test("getInvoiceLines (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    id: "id",
                    orderId: "orderId",
                    orderLineId: "orderLineId",
                    orderLineAttributeId: "orderLineAttributeId",
                    startDate: "2024-01-15T09:30:00Z",
                    endDate: "2024-01-15T09:30:00Z",
                    paymentStatus: "pending",
                    quantity: 1,
                    totalPriceBeforeTax: 1.1,
                    tax: 1.1,
                    taxRate: 1.1,
                    totalPriceAfterTax: 1.1,
                    currency: "currency",
                    description: "description",
                    balanceAmount: 1.1,
                    creditedAmount: 1.1,
                    createdAt: "2024-01-15T09:30:00Z",
                    updatedAt: "2024-01-15T09:30:00Z",
                },
            ],
            pagination: { limit: 1, offset: 1, total: 1, hasMore: true },
        };
        server.mockEndpoint().get("/invoices/id/lines").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.invoices.getInvoiceLines({
            id: "id",
        });
        expect(response).toEqual({
            data: [
                {
                    id: "id",
                    orderId: "orderId",
                    orderLineId: "orderLineId",
                    orderLineAttributeId: "orderLineAttributeId",
                    startDate: "2024-01-15T09:30:00Z",
                    endDate: "2024-01-15T09:30:00Z",
                    paymentStatus: "pending",
                    quantity: 1,
                    totalPriceBeforeTax: 1.1,
                    tax: 1.1,
                    taxRate: 1.1,
                    totalPriceAfterTax: 1.1,
                    currency: "currency",
                    description: "description",
                    balanceAmount: 1.1,
                    creditedAmount: 1.1,
                    createdAt: "2024-01-15T09:30:00Z",
                    updatedAt: "2024-01-15T09:30:00Z",
                },
            ],
            pagination: {
                limit: 1,
                offset: 1,
                total: 1,
                hasMore: true,
            },
        });
    });

    test("getInvoiceLines (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/invoices/id/lines").respondWith().statusCode(403).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.invoices.getInvoiceLines({
                id: "id",
            });
        }).rejects.toThrow(Paid.ForbiddenError);
    });

    test("getInvoiceLines (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/invoices/id/lines").respondWith().statusCode(404).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.invoices.getInvoiceLines({
                id: "id",
            });
        }).rejects.toThrow(Paid.NotFoundError);
    });

    test("getInvoiceLines (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server.mockEndpoint().get("/invoices/id/lines").respondWith().statusCode(500).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.invoices.getInvoiceLines({
                id: "id",
            });
        }).rejects.toThrow(Paid.InternalServerError);
    });
});
