// This file was auto-generated by Fern from our API Definition.

import * as Paid from "../../src/api/index";
import { PaidClient } from "../../src/Client";
import { mockServerPool } from "../mock-server/MockServerPool";

describe("Checkout", () => {
    test("createCheckoutSession (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { product_id: "product_id", success_url: "success_url", cancel_url: "cancel_url" };
        const rawResponseBody = {
            session_id: "session_id",
            token: "token",
            url: "url",
            expires_at: "2024-01-15T09:30:00Z",
        };
        server
            .mockEndpoint()
            .post("/checkout/sessions/")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.checkout.createCheckoutSession({
            product_id: "product_id",
            success_url: "success_url",
            cancel_url: "cancel_url",
        });
        expect(response).toEqual({
            session_id: "session_id",
            token: "token",
            url: "url",
            expires_at: "2024-01-15T09:30:00Z",
        });
    });

    test("createCheckoutSession (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { product_id: "product_id", success_url: "success_url", cancel_url: "cancel_url" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/checkout/sessions/")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.checkout.createCheckoutSession({
                product_id: "product_id",
                success_url: "success_url",
                cancel_url: "cancel_url",
            });
        }).rejects.toThrow(Paid.BadRequestError);
    });

    test("createCheckoutSession (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { product_id: "product_id", success_url: "success_url", cancel_url: "cancel_url" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/checkout/sessions/")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.checkout.createCheckoutSession({
                product_id: "product_id",
                success_url: "success_url",
                cancel_url: "cancel_url",
            });
        }).rejects.toThrow(Paid.NotFoundError);
    });

    test("createCheckoutSession (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });
        const rawRequestBody = { product_id: "product_id", success_url: "success_url", cancel_url: "cancel_url" };
        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/checkout/sessions/")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.checkout.createCheckoutSession({
                product_id: "product_id",
                success_url: "success_url",
                cancel_url: "cancel_url",
            });
        }).rejects.toThrow(Paid.InternalServerError);
    });

    test("getCheckoutSession (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = {
            id: "id",
            token: "token",
            status: "pending",
            product: { id: "id", name: "name", description: "description" },
            customer: { id: "id", name: "name", email: "email", externalId: "externalId" },
            success_url: "success_url",
            cancel_url: "cancel_url",
            metadata: { key: "value" },
            expires_at: "2024-01-15T09:30:00Z",
            completed_at: "2024-01-15T09:30:00Z",
            created_at: "2024-01-15T09:30:00Z",
        };
        server
            .mockEndpoint()
            .get("/checkout/sessions/sessionId")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.checkout.getCheckoutSession({
            sessionId: "sessionId",
        });
        expect(response).toEqual({
            id: "id",
            token: "token",
            status: "pending",
            product: {
                id: "id",
                name: "name",
                description: "description",
            },
            customer: {
                id: "id",
                name: "name",
                email: "email",
                externalId: "externalId",
            },
            success_url: "success_url",
            cancel_url: "cancel_url",
            metadata: {
                key: "value",
            },
            expires_at: "2024-01-15T09:30:00Z",
            completed_at: "2024-01-15T09:30:00Z",
            created_at: "2024-01-15T09:30:00Z",
        });
    });

    test("getCheckoutSession (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/checkout/sessions/sessionId")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.checkout.getCheckoutSession({
                sessionId: "sessionId",
            });
        }).rejects.toThrow(Paid.NotFoundError);
    });

    test("getCheckoutSession (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .get("/checkout/sessions/sessionId")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.checkout.getCheckoutSession({
                sessionId: "sessionId",
            });
        }).rejects.toThrow(Paid.InternalServerError);
    });

    test("cancelCheckoutSession (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { session_id: "session_id", status: "status" };
        server
            .mockEndpoint()
            .post("/checkout/sessions/sessionId/cancel")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.checkout.cancelCheckoutSession({
            sessionId: "sessionId",
        });
        expect(response).toEqual({
            session_id: "session_id",
            status: "status",
        });
    });

    test("cancelCheckoutSession (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/checkout/sessions/sessionId/cancel")
            .respondWith()
            .statusCode(400)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.checkout.cancelCheckoutSession({
                sessionId: "sessionId",
            });
        }).rejects.toThrow(Paid.BadRequestError);
    });

    test("cancelCheckoutSession (3)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/checkout/sessions/sessionId/cancel")
            .respondWith()
            .statusCode(404)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.checkout.cancelCheckoutSession({
                sessionId: "sessionId",
            });
        }).rejects.toThrow(Paid.NotFoundError);
    });

    test("cancelCheckoutSession (4)", async () => {
        const server = mockServerPool.createServer();
        const client = new PaidClient({ token: "test", environment: server.baseUrl });

        const rawResponseBody = { error: "error" };
        server
            .mockEndpoint()
            .post("/checkout/sessions/sessionId/cancel")
            .respondWith()
            .statusCode(500)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.checkout.cancelCheckoutSession({
                sessionId: "sessionId",
            });
        }).rejects.toThrow(Paid.InternalServerError);
    });
});
